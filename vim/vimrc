filetype plugin indent on
syntax enable

set tabstop=2       " Number of spaces that a <Tab> in the file counts for.

set shiftwidth=2    " Number of spaces to use for each step of (auto)indent.

set softtabstop=2   " Same like those above, more or less - maybe.

set expandtab       " Use the appropriate number of spaces to insert a <Tab>.
                    " Spaces are used in indents with the '>' and '<' commands
                    " and when 'autoindent' is on. To insert a real tab when
                    " 'expandtab' is on, use CTRL-V <Tab>.

set smarttab        " When on, a <Tab> in front of a line inserts blanks
                    " according to 'shiftwidth'. 'tabstop' is used in other
                    " places. A <BS> will delete a 'shiftwidth' worth of space
                    " at the start of the line.

set showcmd         " Show (partial) command in status line.

set number          " Show line numbers.
set relativenumber  " Show relative line numbers.

set showmatch       " When a bracket is inserted, briefly jump to the matching
                    " one. The jump is only done if the match can be seen on the
                    " screen. The time to show the match can be set with
                    " 'matchtime'.

set hlsearch        " When there is a previous search pattern, highlight all
                    " its matches.

set incsearch       " While typing a search command, show immediately where the
                    " so far typed pattern matches.

set ignorecase      " Ignore case in search patterns.

set smartcase       " Override the 'ignorecase' option if the search pattern
                    " contains upper case characters.

set backspace=indent,eol,start     " Influences the working of <BS>, <Del>, CTRL-W
                    " and CTRL-U in Insert mode. This is a list of items,
                    " separated by commas. Each item allows a way to backspace
                    " over something.

set autoindent      " Copy indent from current line when starting a new line
                    " (typing <CR> in Insert mode or when using the "o" or "O"
                    " command).

set copyindent      " copy previous indentation

set textwidth=256   " Maximum width of text that is being inserted. A longer
                    " line will be broken after white space to get this width.

set formatoptions=c,q,r,t " This is a sequence of letters which describes how
                    " automatic formatting is to be done.-
                    "
                    " letter    meaning when present in 'formatoptions'
                    " ------    ---------------------------------------
                    " c         Auto-wrap comments using textwidth, inserting
                    "           the current comment leader automatically.
                    " q         Allow formatting of comments with "gq".
                    " r         Automatically insert the current comment leader
                    "           after hitting <Enter> in Insert mode.
                    " t         Auto-wrap text using textwidth (does not apply
                    "           to comments)

set ruler           " Show the line and column number of the cursor position,
                    " separated by a comma.

set mouse=nr        " Enable the use of the mouse. SHOULD BE 'a'

set wildmode=list:longest,full " tab completion: show all matches, then start completing


""""""""""""""""""""""
" FILE-TYPE SPECIFIC "
""""""""""""""""""""""
" md is markdown
autocmd BufNewFile,BufRead md set filetype=markdown

" jsm is javascript
autocmd BufReadPost jsm set syntax=javascript

" files that use semicolons: use COSC plugin
autocmd FileType javascript,css nnoremap <leader>, :CommaOrSemiColon<CR>
autocmd FileType javascript,css inoremap <leader>, <c-o>:CommaOrSemiColon<CR>

" c: compile
autocmd FileType c noremap <F2> :!gcc -o "%:p:r.out" "%:p" && "%:p:r.out"<CR>

" scripts: execute
autocmd FileType lua\|sh noremap <F2> :!"%:p"<CR>

" md: compile and open/compile
autocmd FileType markdown noremap <F2> :!cd "%:p:h" && pandoc -V geometry:margin=1in "%:p" -o "%:p:r.pdf" && okular &> /dev/null "%:p:r.pdf" &<CR>
autocmd FileType markdown noremap <F3> :!cd "%:p:h" && pandoc -V geometry:margin=1in "%:p" -o "%:p:r.pdf" &<CR>

" commit messages: spellchecking and small columns
" enforce small commit message lines
autocmd Filetype gitcommit setlocal textwidth=72
" spellchecking
autocmd FileType md\|gitcommit setlocal spell


set runtimepath=~/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,~/.vim/after

set grepprg=grep\ -nH\ $*

set clipboard=unnamed
set encoding=utf-8

" allow saving files as sudo
cnoremap w!! w !sudo tee % > /dev/null

set pastetoggle=<F7>

" make j/k move down/up one ROW rather than one LINE
nnoremap j gj
nnoremap k gk


" load pathogen
execute pathogen#infect()
" not sure whether the following line is necessary
call pathogen#helptags()


" word complete
set complete+=kspell


" This rewires n and N to do the highlighing...
" TODO: fix - maybe that was introduced with vim 8..?
nnoremap <silent> n   n:call HLNext(0.4)<cr>
nnoremap <silent> N   N:call HLNext(0.4)<cr>

" add blinkhighlight when browsing trough matches
function! HLNext (blinktime)
  let [bufnum, lnum, col, off] = getpos('.')
  let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
  let target_pat = '\c\%#\%('.@/.'\)'
  let ring = matchadd('ErrorMsg', target_pat, 101)
  redraw
  exec 'sleep ' . float2nr(a:blinktime * 500) . 'm'
  call matchdelete(ring)
  redraw
endfunction

" NERDTree file filter
let NERDTreeIgnore = [ '\.bbl$', '\.blg$', '\.aux$', '\.bcf$', '\.dvi$', '\.lof$', '\.lot$', '\.out$', '\.pdf$', '\.toc$', '\.swp$' ]

" map save, close all
noremap <C-s> <esc>:w<CR>
inoremap <C-s> <esc>:w<CR>a
noremap <C-c> <esc>:q<CR>
inoremap <C-c> <esc>:q<CR>
noremap <C-q> <esc>:qa<CR>
inoremap <C-q> <esc>:qa<CR>
abbrev Qa qa

" map leader
" unhighlight search results
noremap <Leader>q :nohlsearch<CR>
noremap <Leader>yy ggVG"*y
noremap <Leader>n :NERDTreeToggle<CR>
noremap <Leader>dr :E ~/dropbox<CR>
noremap <Leader>vim :e $MYVIMRC<CR>
noremap <Leader>ss :so $MYVIMRC<CR>
noremap <Leader>b :e ~/.bashrc<CR>
noremap <Leader>rw :%s/\s\+$//<cr>:nohlsearch<cr>
noremap <Leader>w <C-w>w

" Edit another file in the same directory as the current file
" uses expression to extract path from current file's path
noremap <Leader>e :e <C-R>=escape(expand("%:p:h"),' ') . '/'<CR>
noremap <Leader>sh :split <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>
noremap <Leader>sv :vnew <C-R>=escape(expand("%:p:h"), ' ') . '/'<CR>

" change TeX placeholder movement
" NOTE: this stays in vimrc because we can use these placeholders in other files too
imap <C-g> <Plug>IMAP_JumpForward
nmap <C-g> <Plug>IMAP_JumpForward

" insert TeX placeholder
nnoremap <Leader>g i<++><Esc>hi
inoremap <Leader>g <++><Esc>i

" jump to TeX next placeholder
nnoremap <C-n> /<+.*+><CR>:nohlsearch<CR><Esc>cf>
inoremap <C-n> <Esc>/<+.*+><CR>:nohlsearch<CR><Esc>cf>

" easier window navigation
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

set gdefault " assume the /g flag on :s substitutions to replace all matches in a line


"============================================================================
" Make :help appear in a full-screen tab, instead of a window
"============================================================================

"Only apply to .txt files...
augroup HelpInTabs
  autocmd!
  autocmd BufEnter  *.txt   call HelpInNewTab()
augroup END

"Only apply to help files...
function! HelpInNewTab ()
  if &buftype == 'help'
    "Convert the help window to a tab...
    execute "normal \<C-W>T"
  endif
endfunction

" automatically re-source vimrc - which messes up airline, so refresh that
autocmd! BufWritePost $MYVIMRC source $MYVIMRC
autocmd! BufWritePost $MYVIMRC AirlineRefresh

" for vim-obsess
set titlestring=%{ObsessionStatus('[R]','[x]')}%(\ %)%t%(\ %M%)%(\ (%{expand(\"%:p:h\")})%)%(\ %a%)\ -\ %{v:servername}
noremap <Leader>o :Obsess<CR>
noremap <Leader>O :Obsess!<CR>

" adding pairs of matching characters
set matchpairs+=<:>,=:;


" visual mode: < and > indent block and re-select previous indentation too
vnoremap < <gv
vnoremap > >gv

" Jump to last cursor position when opening a file
autocmd BufReadPost * call s:SetCursorPosition()
function! s:SetCursorPosition()
    if &filetype !~ 'svn\|commit\c'
        if line("'\"") > 0 && line("'\"") <= line("$")
            exe "normal! g`\""
            normal! zz
        endif
    end
endfunction

" buffers are hidden, rather than closed
"set hidden

set history=1000         " remember more commands and search history
set undolevels=5000      " use many muchos levels of undo
set wildignore+=*.swp     " ignore swapfiles when completing filenames
set title                " change the terminal's title

" Q autoformats the current selection or paragraph
vnoremap Q gq
" nnoremap Q gqap

" Bubble single lines
nnoremap <silent> <C-Up>   :move-2<CR>==
nnoremap <silent> <C-Down> :move+<CR>==
" Bubble multiple lines
xnoremap <silent> <C-Up>   :move-2<CR>gv=gv
xnoremap <silent> <C-Down> :move'>+<CR>gv=gv

"Duplicate lines above and below
inoremap <C-A-down> <esc>Ypk
nnoremap <C-A-down> Ypk
xnoremap <C-A-down> y`>pgv
inoremap <C-A-up> <esc>YPj
nnoremap <C-A-up> YPj
xnoremap <C-A-up> y`<Pgv

"Jump back to last edited buffer
nnoremap <C-b> :e#<CR>
inoremap <C-b> <esc>:e#<CR>

" git(-plugin)-related stuff
set tags=.git/tags,tags           " Look for tags in .git/
nmap ]h <Plug>GitGutterNextHunk
nmap [h <Plug>GitGutterPrevHunk
nmap <Leader>ha <Plug>GitGutterStageHunk
nmap <Leader>hr <Plug>GitGutterRevertHunk

" Backspace deletes buffer.
nnoremap <BS> :bd<CR>

set scrolloff=5 " Show 5 lines of context around the cursor.

" use magic regex mode by default
"nnoremap / /\v

" search for what's visually selected by pressing `//`
vnoremap // y/<C-R>"<CR>

nnoremap <Leader>p :CtrlPTag<CR>
nnoremap <Leader>t :TagbarToggle<CR>

" CtrlP: ignore files in .gitignore
"let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
let g:ctrlp_custom_ignore = {
  \ 'dir': '\v\/?gen|node_modules|vendor|.*-venv\/?'
  \ }
set wildignore+=*.pyc
set wildignore+=__init__.py

map w <Plug>CamelCaseMotion_w
map b <Plug>CamelCaseMotion_b
map e <Plug>CamelCaseMotion_e

" duplicate visual mode selection
vnoremap D y'>p

" Press Shift+P while in visual mode to replace the selection without
" overwriting the default register
vnoremap P p :call setreg('"', getreg('0'))<CR>

" bind K to search word under cursor
nnoremap K :Ag "\b<C-R><C-W>\b"<CR>:cw<CR>

" Open new split panes to right and bottom, which feels more natural
set splitbelow
set splitright

" insert snippet from trigger
let g:UltiSnipsExpandTrigger="<Leader><Space>"
" show all potential snippets with current trigger
let g:UltiSnipsListSnippets="<Leader><Tab>"
" always look for snippets here (so UltiSnipsEdit can be used)
let g:UltiSnipsSnippetsDir="~/git/dotfiles/vim/bundle/vim-snippets/UltiSnips/"

" When at 3 spaces and I hit >>, go to 4, not 5.
set shiftround

" Execute macro in q
nnoremap Q @q

" Quickfix management
noremap <Space><Space> :ccl<CR>:pclose<CR>

" Make CtrlP use ag for listing the files. Way faster and no useless files.
"let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
let g:ctrlp_use_caching = 0

" Don't wait so long for the next keypress (particularly in ambigious Leaderkdsjflsa jflksadjf dsalkfj sadlfj
" situations.
set timeoutlen=500


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" RENAME CURRENT FILE (thanks Gary Bernhardt)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
noremap <Leader>rn :call RenameFile()<cr>
" do not store runtimepath in session file - that doesn't work with pathogen
set sessionoptions-=options

autocmd BufReadPost fugitive://* set bufhidden=delete
nnoremap <silent> <leader>tn :TestNearest<CR>
nnoremap <silent> <leader>tf :TestFile<CR>
nnoremap <silent> <leader>tt :TestSuite<CR>
nnoremap <silent> <leader>tl :TestLast<CR>

let g:indentLine_char = 'â”†'

let g:test#javascript#mocha#options = {
  \ 'file':    '--check-leaks --full-trace --inline-diffs --no-exit',
  \ 'nearest': '--check-leaks --full-trace --inline-diffs --no-exit',
  \ 'suite':   '--check-leaks --full-trace --inline-diffs --no-exit --recursive'
\}

" for command mode
nnoremap <S-Tab> <<
" for insert mode
inoremap <S-Tab> <C-d>

" wrap word under cursor/selection in quotes - they don't always work and are just for playing around
nnoremap <leader>" viw<Esc>a"<Esc>hbi"<Esc>lel
inoremap <leader>" <Esc>viw<Esc>a"<Esc>hbi"<Esc>lela
vnoremap <leader>" o<Esc>i"<Esc>gvo<Esc>la"<Esc>
nnoremap <leader>' viw<Esc>a'<Esc>hbi'<Esc>lel
inoremap <leader>' <Esc>viw<Esc>a'<Esc>hbi'<Esc>lela
vnoremap <leader>' o<Esc>i'<Esc>gvo<Esc>la'<Esc>

" remember vim home directory
let $VIMHOME=expand('<sfile>:p:h')

