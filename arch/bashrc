#!/usr/bin/env bash

# if not running interactively, don't do anything
[[ $- != *i* ]] && return

export TERM="screen-256color"

###############################################################################
# PS1
###############################################################################

# prompt
COLOR_BLACK="\[$(tput setaf 0)\]"
COLOR_RED="\[$(tput setaf 1)\]"
COLOR_GREEN="\[$(tput setaf 2)\]"
COLOR_BROWN="\[$(tput setaf 3)\]"
COLOR_BLUE="\[$(tput setaf 4)\]"
COLOR_MAGENTA="\[$(tput setaf 5)\]"
COLOR_CYAN="\[$(tput setaf 6)\]"
COLOR_LGRAY="\[$(tput setaf 7)\]"

COLOR_DGRAY="\[$(tput setaf 8)\]"
COLOR_LRED="\[$(tput setaf 9)\]"
COLOR_LGREEN="\[$(tput setaf 10)\]"
COLOR_YELLOW="\[$(tput setaf 11)\]"
COLOR_LBLUE="\[$(tput setaf 12)\]"
COLOR_LMAGENTA="\[$(tput setaf 13)\]"
COLOR_LCYAN="\[$(tput setaf 14)\]"
COLOR_WHITE="\[$(tput setaf 15)\]"

COLOR_RESET="\[$(tput sgr0)\]"

echo -e "$(tput sgr0)Welcome to the $(tput setaf 12)other side$(tput sgr0)...\n"

# set up git PS1
GIT_PS1_FILE="$HOME/git/dotfiles/arch/third-party/git-prompt.sh"
[[ -f "$GIT_PS1_FILE" ]] && source "$GIT_PS1_FILE"
export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWSTASHSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true
export GIT_PS1_SHOWUPSTREAM="auto" # verbose

PS1="${COLOR_DGRAY}["
PS1+="${COLOR_WHITE}\$?"
PS1+="\$(if [[ \$? == 0 ]]; then echo \"  ${COLOR_LGREEN}\342\234\223\";"
PS1+="else printf '%-3s' ${COLOR_LRED}\342\234\227; fi)${COLOR_DGRAY}]"
PS1+="[${COLOR_WHITE}\A${COLOR_DGRAY}]"
PS1+="[${COLOR_WHITE}\u${COLOR_DGRAY}@${COLOR_WHITE}\h${COLOR_DGRAY}]"
PS1+="[${COLOR_WHITE}\w"
PS1+="\$([[ \$(__git_ps1) ]]&&echo -n "$COLOR_DGRAY➤"&&__git_ps1|tr -d ' =')"
PS1+="${COLOR_DGRAY}]${COLOR_RESET}${COLOR_LBLUE}\$ ${COLOR_RESET}"


###############################################################################
# basic terminal config
###############################################################################

# exports
export EDITOR="vim"
export VISUAL="vim"
export PAGER="/bin/less"

# history configuration
# append to the history file, don't overwrite it
shopt -s histappend
# save multi-line commands as one command
shopt -s cmdhist
# record each line as it gets issued
PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND ;} history -a"
# history size
export HISTSIZE=5000000
export HISTFILESIZE=10000000
# ignore duplicates and some commands
export HISTCONTROL=ignoreboth:erasedups
export HISTIGNORE="history;ls;date;man *;exit;:q;bg;fg"
# Useful timestamp format
HISTTIMEFORMAT='%F %T '

# easier navigation
# auto-cd when entering path
shopt -s autocd
# do some name autocorrecting
shopt -s dirspell
shopt -s cdspell
# fixes line shenanigans(?)
shopt -s checkwinsize
# add some paths for easier navigation
CDPATH=".:~/git:~/git/sedimentum"

eval "$(dircolors -b)" # highlight broken symlinks
stty -ixon # disable flow control (to use ctrl+s in vim)
# stty erase '^?' # backspace is the erase character


###############################################################################
# aliases - modifications
###############################################################################

# privileged access
if [ $UID -ne 0 ]; then
  alias scat='sudo cat'
  alias svim='sudo vim'
fi

# modified commands
alias diff='colordiff -s' # requires colordiff package
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias ip='ip -color=auto'
alias df='df -h'
alias du='du -c -h'
alias mkdir='mkdir -p -v'

alias cd='cd -P'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias .......='cd ../../../../../..'

alias l='ls'
alias ls='ls -lhF --color=auto'
alias lr='ls -R'                    # recursive ls
alias la='ls -a'
alias lx='la -BX'                   # sort by extension
alias lz='la -rS'                   # sort by size
alias lt='la -rt'                   # sort by date
alias ll='la'

# safety features
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -I'                    # -i prompts for every file, -I once when removing more than 3 files
alias ln='ln -i'
alias chown='chown --preserve-root'
alias chmod='chmod --preserve-root'
alias chgrp='chgrp --preserve-root'

# new basic commands
alias rmr='rm -r'
alias fucking='sudo'
alias xclip='xclip -selection c'
alias xpaste='xclip -o'
alias du1='du --max-depth=1'
alias du1s='du1 | sort -h'
alias hist='history | grep'


###############################################################################
# git
###############################################################################

# `g` -> `git status`, `g foobar` -> `git foobar`
function g {
   if [[ $# -gt 0 ]]; then
     git "$@"
   else
     git status  || ls
   fi
}
# load git completion
GIT_COMPLETION_FILE="/usr/share/bash-completion/completions/git"
[[ -f "$GIT_COMPLETION_FILE" ]] && source "$GIT_COMPLETION_FILE"
# add `git` completion for `g`
eval "$(complete -p git | rev | cut -b 3- | rev)"
alias ga='git add'
alias gaa='git add -A'
alias gap='git add -p'
alias gc='git commit -v'
alias gs='git status || ls'
alias gd='git diff'
alias gds='git diff --staged'
alias gda='git diff HEAD'
alias gf='git fetch'
alias gaa='git add -A'
OM='origin/master'


###############################################################################
# new commands
###############################################################################

# diagnostics
alias find-broken-symlinks='find . -type l | (while read FN ; do test -e "$FN" || ls -ld "$FN"; done)'
alias files='file $(/usr/bin/ls -aH)'
alias openports='ss --all --numeric --processes --ipv4 --ipv6'
recent() {
  if [ "$1" -eq "$1" ] 2>/dev/null; then
    find . -maxdepth "$1" -type f -mtime -1 -printf "%T@ - %Tk:%TM - %f\n" \
      | sort -rn | cut -d- -f2-
  else
    find . -maxdepth 1 -type f -mtime -1 -printf "%T@ - %Tk:%TM - %f\n" \
      | sort -rn | cut -d- -f2-
  fi
}
p8 () {
  STATUS=0
  LOOP=1
  while [ "$LOOP" -eq 1 ]; do
    ping 8.8.8.8
    STATUS=$?
    if [ $STATUS -eq 0 ]; then
      LOOP=0
    else
      sleep 1
    fi
  done
}

# interactive rename if no destination is specified
function mv() {
  if [ "$#" -ne 1 ] || [ ! -e "$1" ]; then
    command mv -i "$@"
    return
  fi
  read -ei "$1" newfilename
  command mv -i -v -- "$1" "$newfilename"
}

# utilities and convenience
alias ='exit'
alias ='fg' # hit  to resume background paused process (fg)
alias ta='tmux a'
alias tclip='tmux show-buffer | xclip' # put current tmux buffer in clipboard
# alias watch='\watch '   # allow alias expansion for watch argument
alias .='source'
alias reload-bashrc='source ~/.bashrc'
alias tf='tail -F'
alias activate-venv='. venv/bin/activate'
alias clearswap='sudo swapoff -a; sudo swapon -a'
alias docker-stopall='docker stop $(docker ps -q)'
alias repeat-last='cmd=$(fc -ln -1); while true; do $cmd; read; done'
alias repeat-last-auto='cmd=$(fc -ln -1); while true; do $cmd; sleep 1; done'
alias weather='curl wttr.in'

sus(){ sort | uniq -c | sort "$@"; }
historygram(){
  # histogram of command usage
  history|awk '{print $4}'|sort|uniq -c|sort -rn|head -30|awk '!max{max=$1;}{r="";i=s=100*$1/max;while(i-->0)r=r"#";printf "%50s %5d %s %s",$2,$1,r,"\n";}'
}
shrug(){ echo -n "¯\_(ツ)_/¯" | (xclip||xsel||pbcopy);echo "¯\_(ツ)_/¯ copied"; }
x(){
  # extract different kinds of archives
  if [ -f "$1" ] ; then
    case "$1" in
      *.tar.bz2)   tar xvjf "$1"    ;;
      *.tar.gz)    tar xvzf "$1"    ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xvf "$1"     ;;
      *.tbz2)      tar xvjf "$1"    ;;
      *.tgz)       tar xvzf "$1"    ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "Unable to extract '$1'" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}
function box() {
  # draw a boux around the text passed as $1
  t="$1xxxx"
  c=${2:-#}
  echo "${t//?/$c}"
  echo "$c $1 $c"
  echo "${t//?/$c}"
}
function save-as-image() {
  # pipe text to save to this function and add filename
  # e.g. ls | save-as-image foo.png
  convert label:@- "$1"
}
function mp4tomp3() {
  # extract audio from video
  ffmpeg -i "$1" -q:a 0 -map a "$(basename "$1" .mp4).mp3"
}


###############################################################################
# miscellaneous
###############################################################################

source /usr/share/doc/pkgfile/command-not-found.bash

if pgrep ssh-agent > /dev/null; then
  source ~/git/ssh-find-agent/ssh-find-agent.sh
  set_ssh_agent_socket
else
  eval "$(ssh-agent)" > /dev/null
fi

# source other files
{ [[ -f "$HOME/.bash-sourcer.sh" ]] && source "$HOME/.bash-sourcer.sh"; } || true

